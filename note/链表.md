### 链表
* 节点类型:   
``` java
class Node {
	ElemType date
	Node next;
}
```
链表属性：头节点Node haed;
链表方法：

* 头插法：待插入节点.next指向head指向的节点，head指向新插入的节点（唯一一个不用判断链表是否为空的操作）
* 尾插法：
  1. 判断链表是否为空？若为空则将head指向待插入节点，否则将尾节点.next指向待插入节点；
* 删除指定值元素（只删除第一个即可）
  1. 判断删除的节点是否是头节点？是就将head指向head.next，否则找到删除节点的前一个节点，并将其next指向待删除节点的后一个元素；
* 删除链表中所有值为给定值的节点
  1. 此时将头节点单独考虑，先判断头节点之后的节点是否是要删除节点，删除完成后在判断是否头节点也要删除？
* 找到链表中间节点（奇数个节点返回中间，偶数个节点返回中间偏后位置
  1. cur=cur.next循环len/2次此时cur指向的就是len/2+1处的节点（就是要找的节点）
  2. 快慢指针法：快节点走两步，慢节点走一步，快节点到头了慢节点指向就是要找的节点
 ##### 1.删除链表中等于给定值**va1** 的所有节点。
	1. 链表为空则结束。
	2. 从链表第二个节点开始判断，如果值为val则删除此节点，循环遍历整个链表结束 。
	3. 判断头节点值是否为val，如果是就删除掉
``` java
public void removeAll(ElemType val){
	if(head == null){
		return ;
	}
	Node cur = head;
	while(cur.next != null){
		if(cur.next.date == val){//从第二个节点开始判断
			cur = cur.next.next;		
		}else{
			cur = cur.next;		
		}
	}
	if(head.date == val){
		head = head.next;	
	}
} 
```
*设置prev法解决；
``` java
public void removeAll(ElemType val){
	if(head == null){
		return ;
	}
	Node cur = head.next;
	Node prev = head;
	while(cur != null ){
		if(cur.date == val){
			prev.next = cur.next;
			cur = cur.next;
		}else{
			prev = prev.next;
			cur = cur.next
		}
	}
	if(head.date == val){
		head = head.next;	
	}
}
```

##### 2.反转-一个单链表。
 	1. 设置prev节点，和cur节点
 	2. 设置临时局部节点next保存cur.next;
 	3. 让cur.next指向prev，同时prev和cur后移即prev=cur,cur=next;
``` java
public Node reverseList(){
	if(head == null || head.next == null){
		return head;;
	}
	Node prev = null;
	Node cur = head;
	while(cur != null){
		Node next = cur.next;
		cur.next = prev;
		prev = cur;
		cur = next;
	}
	head = prev;
	return head;
}
``` 

#####  3.给定一个带有头结点head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
	1. 普通做法：cur遍历到len/2处；
	2. 快慢指针发：快的一次走两步，慢的一次走一步。(快的踩的点是2n+1,慢的踩的点是n+1)
	快的.next.next为null时慢的.next就是要求节点（偶数节点数）或.next为null时slow就是要求节点(奇数个节点)
	如果直接判断'cur' != null,由于快指针一次走两步就可能发生了空指针异常；
``` java
//普通方法
public Node midNode(){
	if(head == null || head.next == null){
		return head;
	}
	int len = 0;
	Node cur = head;
	while(cur != null){
		len++;
		cur = cur.next;
	}
	cur = head;
	for(int i = 0; i < len/2 ; i++){
		cur = cur.next;
	}
	return cur;
}
```

``` java
//快慢节点法
public Node midNode(){
	if(head == null || head.next == null){
		return head;
	}
	Node fast = head;
	Node slow = head;
	while(fast.next != null && fast.next.next != null){//顺序可不能反，注意空指针异常
		fast = fast.next.next;
		slow = slow.next;
	}
	if(fast.next != null){////顺序可不能反，注意空指针异常
		return slow;
	}else{
		return slow.next;
	}
```

##### 4.输入一个链表，输出该链表中倒数第k个结点。
	1. 普通做法：len-k处
	2. 快慢指针发：快的先走K步 ，然后快慢一起走快的到头慢的就是要求节点。
``` java
public Node FindKthToTail(int k){
 	if(head == null  ){
		return head;
	}
	int len = 0;
	Node cur = head;
	while(cur != null){
		len++;
		cur = cur.next;
	}
	if( k > len || k <= 0){
		return null;
	}
	cur = head;
	for(int i = 0; i < len-k ; i++){
		cur = cur.next;
	}
	return cur;
}
```

``` java
//快慢指针
public Node FindKthToTail(int k){
//缺省了k的合法性判断；
	if(head == null  ){
		return head;
	}
	Node fast = head;
	Node slow = head;
	for(int i = 0; i < k ; i++){
		fast = fast.next;
	}
	while(fast != null){
		fast = fast.next;
		slow = slow.next;
	}
	return slow;
}
	
```
##### 5.将两个有序链表合并为一个新的有序第一步判断如果连链表中有任链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
	1. 意一个为空链表，则返回另一个链表（点两链表都为空是返回的就是null）
	2. 设置两个节点作为迭代器分别遍历两个链表，去两节点中val较小的节点插入到第三个链表中对应的迭代器后移，直到有一个链表遍历完。
	3. 将有剩余链表部分续到目标链表后面。
``` java
public Node mergeTwoLists(ListNode l1, ListNode l2) {
	Linklist list3 = new Linklist() ;
	Node cur3 = list3.head;
	if(list1.head == null){
		return list2.head;
	}
	if(list2.head == null){
		return list1.head;
	}
	Node cur1 = list1.head; 
	Node cur2 = list2.head; 
	while(cur1 != null && cur2 != null){
		if(cur1.date >= cur2.date){
		Node node = new Node(cur2.date);//为了不破坏原来链表；
			if(list3.head == null){
				list3.head = node;
				cur3 = list3.head;
			}else{
				cur3.next = node;
				cur3 = cur3.next;
				cur2 = cur2.next;
			}
		}else{
		Node node = new Node(cur1.date);
			if(list3.head == null){
				list3.head = node;
				cur3 = list3.head;
			}else{
				cur3.next = node;
				cur3 = cur3.next;
				cur1 = cur1.next;
			}	
		}
	}
	if(cur1 != null){
		cur3.next = cur1;
	}else{
		cur3.next = cur2;
	}
	return list3.head;
}
```

##### 6.编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前。
	1. 新创建两个链表一个存储大于X的节点一个存储小于X的节点。将两链表拼接将链表尾节点置为null
``` java
public Node partition(int x){
    if(head == null){
        return null;
    }
    LinkedList small = new LinkedList();
    LinkedList large = new LinkedList();
    Node cur = this.head;
    Node smallTail = small.head;
    Node largeTail = large.head;
    while(cur != null){
        Node node = new Node(cur.date);
        if(cur.date > x){
            if(large.head == null){
                large.head = node;
                largeTail = large.head;
                cur = cur.next;
            }else{
                largeTail.next = node;
                largeTail = largeTail.next;
                cur = cur.next;
            }
        }else{
            if(small.head == null){
                small.head = node;
                smallTail = small.head;
                cur = cur.next;
            }else{
                smallTail.next = node;
                smallTail = smallTail.next;
                cur = cur.next;
            }
        }
    }
    largeTail = null;
    smallTail.next = large.head;
    return small.head;
}
```

##### 7.在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。
	1.链表为空或只有一个节点就直接结束； 
	2. if(head.date == head.next.date) 
``` java	
public void deleteDuplication() {
    if (head == null || head.next == null) {
        return;
    }
    Node cur = head;
    Node prev = head;
    while (cur != null && head.date == head.next.date) {
        while (cur.next != null && cur.date == cur.next.date) {
            cur = cur.next;
        }
        cur = cur.next;
        head = cur;
        prev = head;
    }
    //此时head.date != head.next.date;cur应该后移一个
    cur = cur.next;
    while (cur.next != null) {
        if (cur.date == cur.next.date) {
            while (cur.next != null && cur.date == cur.next.date) {
                cur = cur.next;
            }
            cur = cur.next;//此时cur指向的是不同于之前的重复元素，应进行继续循环，判断此元素是否唯一
        } else {
            prev.next = cur;
            prev = cur;
            cur = cur.next;
        }
    }
}
```

``` java
public Node deleteDuplication(){
    if(head == null || head.next == null){
        return head ;
    }
    LinkedList retList = new LinkedList();
    Node cur2 = retList.head;
    Node cur = this.head;
    while (cur != null) {
        if (cur.next != null &&cur.date == cur.next.date) {
            while ( cur.next != null&&cur.date == cur.next.date ) {
                cur = cur.next;
            }
            cur = cur.next;
        } else {
            if (retList.head == null) {
                retList.head =  new Node(cur.date);
                cur2 = retList.head;
                cur = cur.next;
            } else {
                cur2.next = new Node(cur.date);
                cur2 = cur2.next;
                cur = cur.next;
            }
        }
    }
    return  retList.head;
}	
```
	
#####   8.链表的回文结构。
	1. 将链表从len/2 + 1处开始逆置
``` java	
public boolean chkPalindrome() {
    if(head == null || head.next == null){
        return true ;
    }
    int len = 0;
    Node cur = head;
    while(cur != null){
        cur = cur.next;
        len++;
    }
    cur = head;
    len/=2;
    for(int i = 0; i < len; i++){
        cur = cur.next;
    }
    Node prev = null;
    Node head2 = null;
    while(cur != null){
        if(cur.next == null){
            head2 = cur;
        }
        Node next = cur.next;
        cur.next = prev;
        prev = cur;
        cur = next;
    }
    Node cur1 = head;
    Node cur2 = head2;
    while(cur1 != null && cur2 != null){
        if(cur1.date != cur2.date){
            return false;
        }
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    return true;
}
```
##### 9.输入两个链表，找出它们的第一个公共结点。
	1. 长链表迭代器先走完两个链表长度的差值，然后两迭代器同步进行遍历链表找到第一个.next相同的节点，此时.next所指向就是交点。
``` java
public Node getIntersectionNode(Node headA, Node headB){
	int lenA = 0;
	int lenB = 0;
	Node cur1 = headA;
	Node cur2 = headB;
	while(cur1 != null){
        cur1 = cur1.next;
        lenA++;
    }
    while(cur2 != null){
        cur2 = cur2.next;
        lenB++;
    }
    cur1 = headA;
    cur2 = headB;
	if(lenA > lenB){
		int len = lenA-lenB;
		for(int i = 0 ; i < len; i++ ){
		 cur1 = cur1.next;
		}
	}else{
		int len = lenB-lenA;
		for(int i = 0 ; i < len; i++ ){
		 cur2 = cur2.next;
		}
	}
	while(cur1.next != cur2.next ){
		cur1 = cur1.next;
		cur2 = cur2.next;
	}
	return cur1.next;
	
} 
```

##### 10.给定一个链表， 判断链表中是否有环。
快慢指针法，快指针一次走两步，慢指针一次走一个节点，如果两只这相遇
``` java
public boolean Ishuan(){
	 if(head == null || head.next == null){
        return false ;
    }
    Node fast = head;
    Node slow = head;
    while(fast.next != null && fast.next.next != null){
    	fast = fast.next.next;
    	slow = slow.next;
    	if(fast == slow ){
    		return true;
    	}
    }
    return false;
}
```
##### 11. 给定一个链表，返回链表开始入环的第一 个节点。 如果链表无环，则返回nu11
*[更多练习见力扣——链表讲解](https://github.com/eternityfantastic/study/blob/master/note/%E5%8A%9B%E6%89%A3%E2%80%94%E9%93%BE%E8%A1%A8.md)
  
