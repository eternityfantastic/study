### 继承（is - a）

#### 重写(覆盖)父类方法
* 重写：方法头完全相同，方法体不同；具体如下：
（1）重写方法不能缩小访问权限；
（2）参数列表必须与父类方法相同（包括显示形式）；
（3）返回类型必须与父类方法的相同或是其子类；
（4）重写方法不能抛出新的异常，或者超过了父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常。

#### 新增方法（重载和新增）；
* 重载
（1）方法名相同；
（2）方法参数列表不同（参数个数，参数类型）
（3）方法返回值类型不影响重载；
重载不覆盖旧方法而是添加了新方法；
#### 向上转型：声明父类 的对象引用，引用子类的对象；father f = new Son();
编译时会按照父类类型来检查方法的调用（因此引用f不能调用子类新增的方法）；
运行时操作数栈压入的是子类的实例Son的实例对象（因此调用的是子类的方法）；
#### 相比于C++，Java自带动态绑定效果
##### 动态绑定和静态绑定
__动态绑定__：动态绑定是指在执行期间（非编译期）判断所引用对象的实际类型
，根据其实际的类型调用其相应的方法。程序运行过程中，
把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。
__静态绑定__:是指在程序运行前就已经知道方法是属于那个类的，
在编译的时候就可以连接到类的中，定位到这个方法；
* C++：（virtual声明的不直接装入，等运行时发现没有在装入）
	* 在C++运行时将经过完整的编译链接装入后的代码放在代码段，只有用virtual声明的函数或类才是动态绑定；
	而实现虚函数动态绑定的原理是将虚函数的地址放在虚函数表中，程序运行时通过对象实例的地址得到这张虚函数表，
	然后就可以遍历其中函数指针，并调用相应的函数；
	* 虚析构是应用比较多的
* Java：
	每个类被加载到虚拟机时，在方法区保存元数据，其中，包括一个叫做方法表（methodtable）的东西，
	表中记录了这个类定义的方法的指针，每个表项指向一个具体的方法代码。
	如果这个类重写了父类中的某个方法，则对应表项指向新的代码实现处。。	
	
		

