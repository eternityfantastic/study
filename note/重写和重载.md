###
我们知道，向上转型时，用父类引用执行子类对象，并可以用父类引用调用子类中重写了的同名方法。但是不能调用子类中新增的方法。
在代码的编译阶段，编译器通过声明对象的类型（即引用本身的类型）在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编译通过。（这里是根据声明的对象类型来查找的，所以此处是查找Father类的方法表，而Father类方法表中是没有子类新增的方法的，所以不能调用。）
编译阶段是确保方法的存在性，保证程序能顺利、安全运行。

重写（覆盖）：方法头完全相同，方法体不同。
#### 动态绑定和静态绑定
__动态绑定__：动态绑定是指在执行期间（非编译期）判断所引用对象的实际类型
，根据其实际的类型调用其相应的方法。程序运行过程中，
把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。
__静态绑定__:是指在程序运行前就已经知道方法是属于那个类的，
在编译的时候就可以连接到类的中，定位到这个方法
而在Java中
#### C++的virtual
由于C++在运行时经过完整的编译链接转入将代码放在代码段，所以 就会在子类中嵌入父类代码
而当由菱形继承时，底层子类会对顶层基类，进行多份代码拷贝，因此在访问相应属性时
会有二义性，必须使用 类名“::”来确定那个类的成员属性或方法，
而是用virtual即可规定为动态联编，从而避免了二义性（即所有子类只有一份拷贝）；因此Java抛弃了多重继承理念（不安全，不支持）
虚基类只在子类中由一份拷贝，从而消除菱形继承的二义性，虚函数，是为了子类重写方法后避免二义性，也只是一份拷贝；（Java中所有方法都是虚函数）
//TODO对于动态联编，在Java中类都放在方法区域，解释器会根据引用来确定对应方法或属性；               

__动态联编__：指向基类的指针在操作它的多态类对象时，会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。
而在类加载或程序运行的某个时刻的解析阶段，JVM会将该符号引用解析为直接引用，
解析的顺序为，如果在该字段所属的类（从CONSTANT_Fieldref_info中可以得到）中找到名字和类型相同的字段，
就是用该字段的直接引用。如果没有找到，就会继续查找其父类或接口。
C++ 不定义virtual会编译报错吗?
|C++|虚函数|纯虚函数|抽象类|虚基类|
|:---:| :---:||:---:| :---:|:---:|
|virtual|……|……|不能||
|Java|普通方法|抽象方法|抽象类|接口|
|:---:| :---:||:---:| :---:|:---:|

|纯虚函数|抽象方法|
含有虚函数的类可以实例化，可当作普通类来使用，但含有纯虚函数的类只能被继承后才能使用，


重载：方法头中的参数列表不同，因此可以确定调用那个方法；